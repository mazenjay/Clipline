//
//  NSPasteboard+.swift
//  Clipline
//
//  Created by mazhj on 2025/11/30.
//

import AppKit
import CryptoKit
import Foundation
import PDFKit
import QuickLookThumbnailing
import UniformTypeIdentifiers

// MARK: expand dyn type
extension NSPasteboard.PasteboardType {
    
    static let ignore = NSPasteboard.PasteboardType("dyn.clipline.marker.ignore")
    
    static let remote = NSPasteboard.PasteboardType("com.apple.is-remote-clipboard")
    
    static let mixture = NSPasteboard.PasteboardType("dyn.clipline.marker.mixture")
    
    static let unknown = NSPasteboard.PasteboardType("dyn.clipline.marker.unknown")
    
    static let supports: [NSPasteboard.PasteboardType] = [
        
        // Image
        .tiff,
        .png,
        
        // File
        .fileURL,
        .pdf,
        
        // Text
        .string,
        .html,
        .rtf
    ]
    
    static let transients: Set<String> = [
        "org.nspasteboard.TransientType",   // macOS 标准瞬态标记 (不要持久化)
        "org.nspasteboard.ConcealedType",   // 敏感/隐藏数据标记 (密码管理器常用)
        "org.nspasteboard.AutoGeneratedType", // 自动生成的数据 (某些密码生成器使用)
        "de.peter-maurer.TransientPasteboardType", // LaunchBar 定义的旧标准
        "com.agilebits.onepassword" // 1Password 有时会带这个
    ]
    
    
    func isText() -> Bool {
        if self.rawValue == NSPasteboard.PasteboardType.string.rawValue {
            return true
        }

        guard let utType = UTType(self.rawValue) else {
            return false
        }

        if utType.conforms(to: .text)
            || utType.conforms(to: .html)
        {
            return true
        }

        return false
    }

    func isFile() -> Bool {
        if self.rawValue == NSPasteboard.PasteboardType.fileURL.rawValue {
            return true
        }

        guard let utType = UTType(self.rawValue) else {
            return false
        }

        if utType.conforms(to: .fileURL) || utType.conforms(to: .folder) {
            return true
        }

        return false

    }
    
    func isMixture() -> Bool {
        return NSPasteboard.PasteboardType.mixture.rawValue == self.rawValue
    }
    
    func hasImage() -> Bool {
        if self.rawValue == NSPasteboard.PasteboardType.fileURL.rawValue || self.rawValue == NSPasteboard.PasteboardType.png.rawValue {
            return true
        }
        
        guard let utType = UTType(self.rawValue) else {
            return false
        }

        if utType.conforms(to: .fileURL) || utType.conforms(to: .image) {
            return true
        }
        
        return false

    }
    
    func isImage() -> Bool {
        if self.rawValue == NSPasteboard.PasteboardType.png.rawValue ||
            self.rawValue == NSPasteboard.PasteboardType.tiff.rawValue {
            return true
        }
        
        guard let utType = UTType(self.rawValue) else {
            return false
        }

        if utType.conforms(to: .image) {
            return true
        }
        
        return false
        
    }
}

extension NSPasteboard {
    
    
    struct PasteboardSnapshot {
        let sourceAppBundleID: String
        let items: [[NSPasteboard.PasteboardContent]]
        let isFromRemote: Bool
    }
    
    // MARK: parsed clipboard content
    struct PasteboardContent: Encodable {
        let type: NSPasteboard.PasteboardType
        let content: Data

        enum CodingKeys: String, CodingKey {
            case type, content
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(type.rawValue, forKey: .type)
            try container.encode(
                content.base64EncodedString(),
                forKey: .content
            )
        }
    }
    
    struct ParsedResult: Encodable {
        let contents: [[PasteboardContent]]
        let mainCategory: String
        let showContent: String

        enum CodingKeys: String, CodingKey {
            case contents
            case mainCategory = "main_category"
            case showContent = "show_content"
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(contents, forKey: .contents)
            try container.encode(mainCategory, forKey: .mainCategory)
            try container.encode(showContent, forKey: .showContent)
        }

        var hash: String? {
            do {
                let encoder = JSONEncoder()
                encoder.outputFormatting = .sortedKeys
                let jsonData = try encoder.encode(self)
                let hash = SHA256.hash(data: jsonData)
                return hash.map { String(format: "%02x", $0) }.joined()
            } catch {
                return nil
            }
        }
    }
    
    struct CleanRule {
        let beforeAt: Date?
        let types: [NSPasteboard.PasteboardType]
    }
    
    var isTransient: Bool {
        guard let types = self.types else { return false }
        return types.contains { Self.PasteboardType.transients.contains($0.rawValue) }
    }
}

extension NSPasteboard {
    
    @MainActor
    func createSnapshot() -> PasteboardSnapshot? {
        if self.isTransient {
            return nil
        }
        
        let sourceApp = NSWorkspace.shared.frontmostApplication?.bundleIdentifier ?? "unknown"
        
        guard let pasteboardItems = self.pasteboardItems, !pasteboardItems.isEmpty else {
            return nil
        }
        var snapshotItems: [[PasteboardContent]] = []
        var isRemote: Bool = false
        for item in pasteboardItems {
            
            if item.types.contains(.ignore) { return nil }
            if !isRemote && item.types.contains(.remote) { isRemote = true }
            let availableTypes = item.types
            var contentList: [PasteboardContent] = []
            print(availableTypes)
            
            
            for type in Self.PasteboardType.supports {
                if availableTypes.contains(type),
                   let data = item.data(forType: type) {
                    contentList.append(PasteboardContent(type: type, content: data))
                }
            }
            
            if !contentList.isEmpty {
                snapshotItems.append(contentList)
            }
        }
        
        guard !snapshotItems.isEmpty else { return nil }
        
        return .init(
            sourceAppBundleID: sourceApp,
            items: snapshotItems,
            isFromRemote: isRemote
        )
    }
    
    static func parseSnapshot(snapshot: PasteboardSnapshot) -> ParsedResult? {
        let rawItems = snapshot.items
        guard !rawItems.isEmpty else { return nil }
        
        guard let firstItem = rawItems.first, let firstContent = firstItem.first else {
            return nil
        }
        
        let mainType = firstContent.type
        let flatContents = rawItems.compactMap { $0.first }
        
        return .init(contents: rawItems, mainCategory: mainType.rawValue, showContent: Self.preview(for: flatContents, maintype: mainType) ?? "unknown")
    }
    
    
    func writeToPasteboard(
        items: [[PasteboardContent]],
        ignored: Bool = true
    ) {
        self.clearContents()

        var pasteboardItems: [NSPasteboardItem] = []
        for hi in items {
            let item = NSPasteboardItem()
            item.setData(Data(), forType: .ignore)
            for content in hi {
                item.setData(content.content, forType: content.type)
            }
            pasteboardItems.append(item)
        }

        self.writeObjects(pasteboardItems)
    }

}

// MARK: Preview clipboard content
extension NSPasteboard {
    
    static func preview(for data: Data, with type: NSPasteboard.PasteboardType) -> String {
        guard let utType = UTType(type.rawValue) else {
            return "unknown (\(data.formatBytes()))"
        }
        
        if utType.conforms(to: .image),
            let image = NSImage(data: data) {
            return "Image - \(Int(image.size.width)) × \(Int(image.size.height))"
        }
        
        if utType.conforms(to: .fileURL),
            let urlString = String(data: data, encoding: .utf8),
            let url = URL(string: urlString) {
            return url.lastPathComponent
        }
        
        if utType.conforms(to: .pdf),
            PDFDocument(data: data) != nil
        {
            return "PDFObject (\(data.formatBytes()))"
        }
        
        if utType.conforms(to: .html) || utType.conforms(to: .rtf) {
            let options:
                [NSAttributedString.DocumentReadingOptionKey: Any] =
                    utType.conforms(to: .html)
                    ? [.documentType: NSAttributedString.DocumentType.html]
                    : [.documentType: NSAttributedString.DocumentType.rtf]

            if let attrString = try? NSAttributedString(
                data: data,
                options: options,
                documentAttributes: nil
            ) {
                return attrString.string
            }
        }

        if utType.conforms(to: .plainText) {
            let text =
                String(data: data, encoding: .utf8) ?? String(
                    data: data,
                    encoding: .utf16
                ) ?? ""
            return text
        }

        let typeDescription = utType.localizedDescription ?? type.rawValue
        let formattedSize = data.formatBytes()
        return "\(typeDescription) - \(formattedSize)"
    }
    
    static func preview(for dataSlice: [Data], with type: String)
        -> [String]
    {

        guard let utType = UTType(type) else {
            return ["unknow (\(dataSlice.count))"]
        }

        var views: [String] = []

        for data in dataSlice {
            // Image
            if utType.conforms(to: .image) {
                if let image = NSImage(data: data) {
                    views.append(
                        "Image - \(Int(image.size.width)) × \(Int(image.size.height))"
                    )
                    continue
                }
            }

            // File URL
            if utType.conforms(to: .fileURL) {
                if let urlString = String(data: data, encoding: .utf8),
                    let url = URL(string: urlString)
                {
                    views.append("\(url.lastPathComponent)")
                    continue
                }
            }

            // PDF object
            if utType.conforms(to: .pdf),
                PDFDocument(data: data) != nil
            {
                views.append("PDFObject (\(data.formatBytes()))")
                continue
            }

            // HTML & RTF
            if utType.conforms(to: .html) || utType.conforms(to: .rtf) {
                let options:
                    [NSAttributedString.DocumentReadingOptionKey: Any] =
                        utType.conforms(to: .html)
                        ? [.documentType: NSAttributedString.DocumentType.html]
                        : [.documentType: NSAttributedString.DocumentType.rtf]

                if let attrString = try? NSAttributedString(
                    data: data,
                    options: options,
                    documentAttributes: nil
                ) {
                    views.append(attrString.string)
                    continue
                }
            }

            if utType.conforms(to: .plainText) {
                let text =
                    String(data: data, encoding: .utf8) ?? String(
                        data: data,
                        encoding: .utf16
                    ) ?? ""
                views.append(text)
                continue
            }

            let typeDescription = utType.localizedDescription ?? type
            let formattedSize = data.formatBytes()
            views.append("\(typeDescription) - \(formattedSize)")
        }
        return views

    }

    static func preview(
        for contents: [PasteboardContent],
        maintype maintyp: NSPasteboard.PasteboardType = .mixture
    ) -> String? {

        guard !contents.isEmpty else {
            return nil
        }
        
        if maintyp != .mixture {
            let unityps = Set(contents.compactMap {$0.type})
            let firsttyp = unityps.first ?? .unknown
            let views = preview(for: contents.compactMap {$0.content}, with: firsttyp.rawValue)
            var showContent: String
            if maintyp == .fileURL {
                let str = views.joined(separator: ",")
                showContent =
                    views.count > 1
                    ? "\(views.count) Files: \(str)" : "File: \(str)"
            } else {
                if unityps.count > 1 {
                    return views.first
                }
                showContent = views.joined(separator: "\n")
            }
            return showContent
        }

        var views: [String] = []
        
        for content in contents {
            let typ = content.type.rawValue
            let data = content.content
            
            guard let utType = UTType(typ) else {
                continue
            }

            if utType.conforms(to: .image) {
                if let image = NSImage(data: data) {
                    views.append(
                        "Image - \(Int(image.size.width)) × \(Int(image.size.height))"
                    )
                    continue
                }
            }

            if utType.conforms(to: .fileURL) {
                if let urlString = String(data: data, encoding: .utf8),
                    let url = URL(string: urlString)
                {
                    views.append("\(url.lastPathComponent)")
                    continue
                }
            }

            if utType.conforms(to: .pdf),
                PDFDocument(data: data) != nil
            {
                views.append("PDFObject (\(data.formatBytes()))")
                continue
            }

            if utType.conforms(to: .html) || utType.conforms(to: .rtf) {
                let options:
                    [NSAttributedString.DocumentReadingOptionKey: Any] =
                        utType.conforms(to: .html)
                        ? [.documentType: NSAttributedString.DocumentType.html]
                        : [.documentType: NSAttributedString.DocumentType.rtf]

                if let attrString = try? NSAttributedString(
                    data: data,
                    options: options,
                    documentAttributes: nil
                ) {
                    views.append(attrString.string)
                    continue
                }
            }

            if utType.conforms(to: .plainText) {
                let text =
                    String(data: data, encoding: .utf8) ?? String(
                        data: data,
                        encoding: .utf16
                    ) ?? ""
                views.append(text)
                continue
            }

            let typeDescription = utType.localizedDescription ?? typ
            let formattedSize = data.formatBytes()
            views.append("\(typeDescription) - \(formattedSize)")
        }

        return "Multi-part\n\(views.joined(separator: "\n"))"
    }

    static func preview(
        for dataSlice: [Data],
        with type: String,
        size: NSSize
    ) async
        -> [NSImage?]
    {
        guard let utType = UTType(type) else {
            return []
        }

        var images: [NSImage?] = []

        for data in dataSlice {
            if utType.conforms(to: .image) {
                images.append(NSImage(data: data))
                continue
            }

            if utType.conforms(to: .fileURL) {
                guard let urlString = String(data: data, encoding: .utf8),
                    let url = URL(string: urlString),
                    url.isFileURL,
                    FileManager.default.fileExists(atPath: url.path)
                else {
                    images.append(
                        NSImage(
                            systemSymbolName: "questionmark.diamond.fill",
                            accessibilityDescription: "Invalid file link"
                        )
                    )
                    continue
                }

                let req = QLThumbnailGenerator.Request(
                    fileAt: url,
                    size: size,
                    scale: NSScreen.main?.backingScaleFactor ?? 2.0,  // 适配 Retina 屏幕
                    representationTypes: .thumbnail
                )

                let generator = QLThumbnailGenerator.shared

                do {
                    let representation =
                        try await generator.generateBestRepresentation(for: req)
                    images.append(representation.nsImage)
                } catch {
                    images.append(NSWorkspace.shared.icon(forFile: url.path))
                }
            }
        }

        return images
    }
    
    static func preview(for data: Data, with type: String, limit size: NSSize = NSSize(width: 100, height: 100)) async -> NSImage? {
        guard let utType = UTType(type) else {
            return nil
        }
        
        if utType.conforms(to: .image) {
            return NSImage(data: data)
        } else if utType.conforms(to: .fileURL) {
        }
        
        guard utType.conforms(to: .fileURL),
              let urlString = String(data: data, encoding: .utf8),
              let url = URL(string: urlString),
              url.isFileURL,
              FileManager.default.fileExists(atPath: url.path)
        else {
            return nil
        }
        let scale = await MainActor.run { NSScreen.main?.backingScaleFactor ?? 2.0 }
        let requestSize = CGSize(width: size.width * 2, height: size.height * 2)
        
        let request = QLThumbnailGenerator.Request(
                    fileAt: url,
                    size: requestSize,
                    scale: scale,
                    representationTypes: .all // Request all types of previews, allowing the system to decide the best solution.
                )

        let generator = QLThumbnailGenerator.shared

                do {
                    // Asynchronously generate the best preview representation
                    let representation = try await generator.generateBestRepresentation(for: request)
                    
                    // If the system is unable to generate a thumbnail with specific content for the file, it will return a generic icon
                    // (for example, all .txt files look the same). In this case, we are more inclined to use
                    // an icon that is completely consistent with the Finder.
                    if representation.type == .icon {
                        return NSWorkspace.shared.icon(forFile: url.path)
                    } else {
                        // Only when it is a truly content thumbnail do we use it.
                        return representation.nsImage
                    }
                    
                } catch {
                    print("Thumbnail generation failed. for \(url.lastPathComponent): \(error.localizedDescription)")
                    return NSWorkspace.shared.icon(forFile: url.path)
                }
        
    }
    
    static func preview(for data: Data) -> NSImage? {
        guard let urlString = String(data: data, encoding: .utf8),
              let url = URL(string: urlString),
              url.isFileURL,
              FileManager.default.fileExists(atPath: url.path)
        else {
            return NSImage(data: data)
        }
        
        return previewFile(for: url)
    }
    
    static func previewFile(for url: URL) -> NSImage? {
        return NSWorkspace.shared.icon(forFile: url.path)
    }
    
    
    static func paste() {
        let source = CGEventSource(stateID: .hidSystemState)
        let keyVDown = CGEvent(
            keyboardEventSource: source,
            virtualKey: 0x09,
            keyDown: true
        )  // 0x09 is the key code for 'v'
        keyVDown?.flags = .maskCommand
        let keyVUp = CGEvent(
            keyboardEventSource: source,
            virtualKey: 0x09,
            keyDown: false
        )
        keyVUp?.flags = .maskCommand

        let loc = CGEventTapLocation.cghidEventTap
        keyVDown?.post(tap: loc)
        keyVUp?.post(tap: loc)
    }
    
}


extension ClipboardRepository {
    
    func save(_ content: NSPasteboard.ParsedResult, sourceApp: String) {
        let dbItems: [ClipboardHistoryItem] = content.contents
            .enumerated().compactMap { (idx, item) -> ClipboardHistoryItem in
                ClipboardHistoryItem(
                    itemIndex: Int64(idx),
                    contents: item.enumerated().compactMap {
                        (itemIdx, data) -> ClipboardHistoryContent in
                        ClipboardHistoryContent(
                            type: data.type.rawValue,
                            content: data.content,
                            priority: Int64(itemIdx)
                        )
                    }
                )
            }
        
        let now = Date()
        let hash = content.hash ?? content.showContent
        
        var dbHistory = ClipboardHistory(
            sourceApp: sourceApp,
            showContent: content.showContent,
            hash: hash,
            dataType: content.mainCategory,
            lastUsedAt: now,
            createdAt: now,
            items: dbItems,
        )
        
        do {
            try upsert(history: &dbHistory)
            print("Clipboard saved successfully: \(hash.prefix(6))")
        } catch {
            print("Database insert failed: \(error)")
        }
    }
    
    
    func cleanup(with rules: [NSPasteboard.CleanRule]) {
        for rule in rules {
            guard let date = rule.beforeAt else { continue }
            let types = rule.types.map { $0.rawValue }
            _ = try? deleteOldRecords(types: types, olderThan: date)
        }
    }

    
}
